---
title: "Solid Tumor Example"
description: |
  A workflow to develop a classifier of a subset of solid tumors 
  from methylation array data.
author:
  - name: Mark Chen
    url: https://markgene.github.io/
    affiliation: SJCRH
    affiliation_url: https://www.stjude.org/
date: "`r Sys.Date()`"
citation_url: https://github.com/markgene/yamatClassifier
output: 
  radix::radix_article:
    toc: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE,
  echo = TRUE
)
```

```{r load_lib, message=FALSE, echo=FALSE, eval=TRUE}
library(yamat)
library(yamatClassifier)
library(ggplot2)
library(ggpubr)
library(corrplot)
library(RColorBrewer)
library(plyr)
library(dplyr)
library(RSpectra)
```


# Data

I use the data from the paper by S. Peter Wu et al. entitled [DNA Methylation–Based Classifier for Accurate Molecular Diagnosis of Bone Sarcomas](http://ascopubs.org/doi/full/10.1200/PO.17.00031). It has 36 samples. However, I borrow the methodology manily from the paper by David Capper et al. entitled [DNA methylation-based classification of central nervous system tumours](https://www.nature.com/articles/nature26000).

Download the data from GEO to local directory.

```{r data_dir, eval=TRUE}
# Download data
gse_acc <- "GSE97529"
data_dir <- "~/Downloads/GSE97529"
```

```{r download, eval=FALSE}
rgset <- yamat::get_gse(gse_acc, data_dir)
save(rgset, file = file.path(data_dir, "rgset.Rda"))
```

Normalization. I do not carry out batch effect correction or filtering out probes in this example. But, it is recommended to perform them in real analyses.

```{r norm, eval=FALSE}
# Load pre-calculated.
load(file.path(data_dir, "rgset.Rda"))

# Normalization
gmset <- yamat::normalize(rgset = rgset, norm_method = "swan")
```

Obtain the beta values.

```{r beta, eval=FALSE}
# Beta values
beta_vals <- minfi::getBeta(gmset, offset = 100)
save(beta_vals, file = file.path(data_dir, "beta_vals.Rda"))
```

Obtain and tidy the phenotype data. I add an column of tumor type abbreviations.

```{r tidy_pheno, eval=FALSE}
# Load pre-calculated.
load(file.path(data_dir, "beta_vals.Rda"))
load(file.path(data_dir, "rgset.Rda"))

# Phenotype
pheno_df <- minfi::pData(rgset)
pheno_df$tumor_type <- as.factor(pheno_df$`diagnosis:ch1`) %>%
  mapvalues(
    .,
    from = c("Ewing’s sarcoma", "Osteosarcoma", "Synovial sarcoma"),
    to = c("EWS", "OS", "SS")
  )
save(pheno_df, file = file.path(data_dir, "pheno_df.Rda"))
```

# Unsupervised analysis
## Most variably methylated loci

I use the most variably methylated loci in the unsupervised analysis. I choose 5000 most variable loci. You can choose a different number for your data through exploratory analysis, taking account of the number of samples.

```{r most_variable_loci, eval=TRUE}
load(file.path(data_dir, "beta_vals.Rda"))
load(file.path(data_dir, "pheno_df.Rda"))

top_n <- 5000
beta_vals_mv <-
  yamatClassifier::most_variable(beta_vals, top_n = top_n)
```

```{r figLociBetaSD, eval=TRUE, fig.cap="Distribution of standard deviations of beta values across loci. The vertical line is the threshold of 5000 most variable loci."}
yamatClassifier::density_plot_row_sd(beta_vals, top_n = top_n)
```

## Correlation between samples

I use the most variably methylated loci to calculate pairwise Pearson's correlation coefficients between samples, carry out hierarchical clustering, and visualize the result in heat map.

```{r reorder_samples, eval=TRUE}
beta_cor <- cor(beta_vals_mv)
dd <- as.dist((1 - beta_cor) / 2)
hc <- hclust(dd)
pheno_df <- pheno_df[hc$order, ]
beta_cor <- beta_cor[hc$order, hc$order]
beta_vals_mv <- beta_vals_mv[, hc$order]
beta_vals <- beta_vals[, hc$order]
```

```{r plot_corr, eval=TRUE}
# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
  mat <- as.matrix(mat)
  n <- ncol(mat)
  p.mat<- matrix(NA, n, n)
  diag(p.mat) <- 0
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      tmp <- cor.test(mat[, i], mat[, j], ...)
      p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
    }
  }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(beta_vals_mv)


col <-
  colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
pal <- RColorBrewer::brewer.pal(3, "Dark2")

beta_cor2 <- beta_cor
data.frame(geo_accession = colnames(beta_cor2)) %>%
  dplyr::left_join(as.data.frame(pheno_df), by = "geo_accession") %>%
  dplyr::select(tumor_type) %>%
  unlist() %>%
  as.factor() -> tumor_type
rownames(beta_cor2) <- colnames(beta_cor2) <- tumor_type

corrplot(
  beta_cor2,
  method = "color",
  col = col(200),
  order = "original",
  tl.col = pal[tumor_type],
  tl.pos = "l",
  # Combine with significance
  p.mat = p.mat,
  sig.level = 0.01,
  insig = "pch",
  pch.cex = 0.5,
  pch.col = "grey70",
  # hide correlation coefficient on the principal diagonal
  diag = TRUE
)
```

## Principal component analysis (PCA)

I will transpose the matrix because it is more common to use columns as features and rows as samples in most R functions.

```{r}
beta_vals_mvt <- t(beta_vals_mv)
```

Follow Capper's paper and the instructions on [Statistical Tools for High-Throughput Data Analysis](http://www.sthda.com/english/wiki/print.php?id=206), I carry out PCA in the following steps.

1. Prepare the data: center and scale.
2. Calculate covariance/correlation matrix.

```{r pca12, eval=TRUE}
beta_vals_mvt %>%
  scale(., center = TRUE, scale = TRUE) %>%
  cov() -> loci_cov
```

3. Calculate the eigenvectors and eigenvalues of the covariance matrix. Top 100 is requested. 

```{r pca3, eval=TRUE}
loci_eig <- eigs(loci_cov, k = 50)
ggpubr::ggdensity(
  data.frame(x = loci_eig$values),
  "x", 
  xlab = "PC eigenvalue",
  ylab = "Density"
)
```

Notice: I use `eigs()` function in *Rspectra* package instead of `eigen()` function in *base* because the matrix is large.

4. Choose principal components (PCs). Following Capper's paper, I determine the number of PCs by comparing eigenvalues to the maximum eigenvalue of a PCA using randomize beta values, which is obtained by shuffing sample labels per loci.

```{r figPCA4, eval=TRUE}
# Randomize beta values.
set.seed(123)
lapply(
  seq(nrow(beta_vals_mv)),
  function(i) {
    sample(beta_vals_mv[i, ])
  }
) %>%
  do.call(rbind, .) %>%
  as.matrix() %>%
  t() %>%
  cov() -> loci_cov_randomized

# Calculate eigenvalues of randomized beta values.
loci_eig_randomized <- eigs(loci_cov_randomized, k = 50)

data.frame(ob = loci_eig$values, bg = loci_eig_randomized$values) %>%
  tidyr::gather(key = "type", value = "eigenvalue") %>%
  ggpubr::ggdensity(
    .,
    "eigenvalue",
    xlab = "PC eigenvalue",
    ylab = "Density",
    color = "type",
    fill = "type",
    alpha = 0.6,
    palette = "jco"
  ) +
  ggplot2::geom_vline(
    xintercept = max(loci_eig_randomized$values),
    linetype = "dashed",
    color = "royalblue"
  )

pca_num <- ceiling(max(loci_eig_randomized$values))
```

It is also common approach is to calculate the fraction of total variance retained. As mentioned in the [stackflow post](https://stackoverflow.com/questions/12067446/how-many-principal-components-to-take), "if you divide each value by the total sum of eigenvalues prior to plotting, then your plot will show the fraction of total variance retained vs. number of eigenvalues". 

```{r figPCA42, eval=TRUE}
frac_var <- cumsum(loci_eig$values) / sum(loci_eig$values)

threshold <- 0.95
pca_num2 <- min(which(frac_var > threshold))

data.frame(x = seq(length(frac_var)), y = frac_var) %>%
  ggplot2::ggplot(., ggplot2::aes(x = x, y = y)) +
  ggplot2::geom_path(colour = "royalblue") +
  ggplot2::geom_point(colour = "royalblue") +
  ggplot2::geom_vline(xintercept = pca_num2,
                      colour = "coral",
                      linetype = "dashed") +
  ggplot2::geom_hline(yintercept = threshold,
                      colour = "coral",
                      linetype = "dashed")
```

I choose the larger one.

```{r pca43, eval=TRUE}
if (pca_num < pca_num2)
  pca_num <- pca_num2
```

5. Compute the new dataset.

```{r pca5}
phi <- loci_eig$vectors[, seq(pca_num)]
row.names(phi) <- colnames(beta_vals_mvt)
colnames(phi) <- paste0("PC", seq(pca_num))
beta_vals_transformed <- beta_vals_mvt %*% phi
```

